const res = "B" + "a" + (1 - "hello");
console.log(res); // BaNaN

const res2 = (true && 3) + "d";
console.log(res2); // 3d

const res3 = Boolean(true && 3) + "d";
console.log(res3); // trued

//-------------------------------

/* 3.1. String 
const newString1 = String(123)
const newString2 = 123.toString()
const newString3= 123 + '' 
3.2. Number
const newNumber1 = Number('123')
const newNumber2 = parseInt('123', 10)
const newNumber3 = +'123' 
const newNumber4 = '123' - 1 
3.3. Boolean
const newBoolean1 = Boolean(123)
const newBoolean2 = !0
3.4. Null
const res = null
3.5. Undefined
let res
constole.log(res)
constole.log(data.name)
3.6. Simbol
const newSimbol = Simbol('1qaz')
3.7. bigInt
const newBigInt = BigInt(123456)
const newBigInt1 = 123456n */

//-------------------------------------------------------------------------------------------------------------------------

/* 1. Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает. 

HTTP-метод OPTIONS используется для описания параметров соединения с целевым ресурсом. Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) чтобы указать весь сервер целиком.
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1
Для того, чтобы узнать какие методы запросов поддерживаются сервером, можно воспользоваться curl направить OPTIONS запрос:
curl -X OPTIONS http://example.org -i
Ответ на запрос содержит Allow (en-US) заголовок с поддерживаемыми методами:
HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST */

//-------------------------------------------------------------------------------------------------------------

/* 2. Прочитать и описать ключевые особенности "HTTP" Версии 3.0

HTTP/3 — готовящаяся к стандартизации версия протокола HTTP (HyperText Transfer Protocol). Первоначальное название HTTP/3 — HTTP-over-QUIC. И главное его отличие от предыдущих версий в том, что он использует новый транспортный протокол QUIC, и за счёт этого передаёт данные быстрее.
QUIC (Quick UDP Internet Connection) — транспортный протокол, основанный на UDP.
UDP отличается от TCP тем, что не проверяет правильный порядок и целостность пакетов. Он просто отправляет данные и не требует подтверждать их получение. За счёт этого информация передаётся быстрее, чем по TCP.
Никакой установки соединения UDP не требует. Пакеты передаются сразу, что тоже ускоряет процесс.
Вот поэтому UDP считается более быстрым. Но всё это ведёт к проблемам с надёжностью. Часть пакетов при передаче может потеряться, и нет никакого механизма восстановления.
QUIC решает проблемы обоих протоколов:
1. Сокращает время на установку соединения.
2. Берёт от UDP высокую скорость передачи, но при этом контролирует целостность пакетов.
3. Может передавать несколько пакетов параллельно, что тоже ускоряет их доставку.
Давайте разберём его основные особенности.
1.Быстрая установка соединения
Мы уже рассказали про «тройное рукопожатие» в TCP. К этому надо добавить, что многие сайты работают через HTTPS. Это значит, что поверх TCP-соединения надо установить ещё и TLS-соединение для безопасной передачи данных.
И для этого клиенту и серверу надо обменяться ещё большим количеством сообщений.
QUIC включает в себя TLS 1.3, обеспечивает безопасное зашифрованное соединение, но при этом не требует такого количества «рукопожатий».
Зашифрованное соединение устанавливается сразу. «Рукопожатие» проходит за 3 шага. А если это повторное соединение, то первые данные отправляются одновременно с «рукопожатием».
Всё это позволяет QUIC передавать данные в несколько раз быстрее TCP и при этом обеспечивать высокий уровень безопасности.
2. Быстрая доставка и контроль за целостностью пакетовю
Для проверки целостности пакетов QUIC использует те же механизмы, что и TCP. Принимающая сторона должна подтвердить получение данных. И если какой-то фрагмент информации потерялся, он будет отправлен снова.
За счёт чего тогда данные передаются быстрее?
---- Мультиплексирование. QUIC может передавать несколько потоков данных параллельно, чего не умеет TCP.
---- Если часть данных в каком-то пакете была утеряна, QUIC не будет передавать весь пакет заново. Он отправит только утерянный фрагмент.
---- Потеря информации влияет на доставку только того потока, к которому эта информация относилась. Все остальные потоки данных продолжают передаваться без остановки.
3. Переключение сессий
В QUIC нет привязки к конкретному IP.
Для сравнения, в TCP-соединении участвуют IP клиента и сервера и порты клиента и сервера. И если один из этих параметров меняется, нам нужно открывать новое соединение.
Если пользователь подключается к ресурсу через Wi-Fi, а потом переходит на мобильную сеть, у него меняется IP, и соединение нужно устанавливать заново.
С QUIC такой проблемы нет. В этом протоколе вместо адресов и портов используется идентификатор соединения — Connection UUID. И он не меняется при переходе от Wi-Fi на мобильную сеть. А значит, соединение остаётся, и ничего не нужно открывать заново.
Кроме того, если QUIC может очень легко перейти от Wi-Fi к мобильному интернету, то в теории он может использовать их оба. В передаче данных будет задействовано 2 канала, и пакеты дойдут быстрее.

HTTP/2 использовал TCP на транспортном уровне и TLS на уровне безопасности.В HTTP/3 эти протоколы заменяет QUIC поверх UDP.
Почему бы просто не встроить QUIC в HTTP/2?

Если главное отличие HTTP/3 от HTTP/2 в том, что он использует QUIC, возникает вопрос, а зачем вообще надо было разрабатывать новый протокол, и почему бы просто не использовать HTTP/2 поверх QUIC.
На первый взгляд, это может показаться наиболее простым решением. Но выяснилось, что тут есть ряд сложностей.
1. Сжатие заголовков. В HTTP/2 для этой функции используется алгоритм HPAC. Его работа зависит от порядка доставки запросов получателю.
TCP гарантирует строгий порядок. А вот в QUIC он часто нарушается. И HPAC в этом случае просто не может работать правильно.
Для сжатия заголовков разработали новый алгоритм — QPAC. И он потребовал изменений в HTTP.
2. Дублирующие функции. В HTTP/2 было отдельно реализовано мультиплексирование, управление потоками и несколько других функций, которые включает в себя QUIC. Чтобы не дублировать элементы и не усложнять протокол, в HTTP/3 от них отказались.
Преимущества HTTP/3 над HTTP/2

Итак, главное преимущество HTTP/3 над HTTP/2 в том, что он быстрее за счёт использования QUIC:
1.Быстрее устанавливается соединение.
2. Быстрее передаются пакеты.
3. Лучше работает мультиплексирование.
4. Об установке соединений и передаче пакетов через QUIC мы уже поговорили. Поэтому давайте подробнее обсудим мультиплексирование. */

// -------------------------------------------------------------------------------------------------

/* 3. Прочитать про способы отмены запроса, включая объект "AbortController"
const abortController = new AbortController()
const signal = abortController.signal()

fetch('https://api.com/data', {signal})
    .then(response => response.json())
    .then(data => doStuff(data))
    .catch(error => {
        if (error.name === 'AbortError') {
            console.error('Fetch request timed out')
        } else {
            console.error('Fetch failed', error)
        }
    })

setTimeout(() => {
    abortController.abort()
}, 5000)    


Также можно не прерывать запрос, а можно игнорировать результат выполнения
const PlanetInfo = ({id}) => {
    const [name, setName] = useState(null)

    useEffect(() => {
        let canceled = false
        fetch(`http://swapi.dev/api/planets/${id}`)
        .then(res => res.json())
        .then(data => !canceled && setName(data.name))
        return () => canceled = true
    }, [id])

    return (
        <div>{id} --- {name}</div>
    )
} */

//--------------------------------------------------------------------------------------------------

/* 4. Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 

var ограничена областью видимости функции и если вы попытаетесь обратиться к такой переменной до её объявления вы получите undefined. const и let ограничены областью видимости блока и если вы попытаетесь обратиться к этим переменным до их объявления вы получите ReferenceError.

Интерпретатор JavaScript разделяет объявление и назначение значений для функций и переменных. Ваши объявления «поднимаются» вверх их области видимости перед выполнением.
Этот процесс называется поднятием. Именно благодаря ему мы можем использовать переменную еще до того, как она объявлена.
Чисто в качестве напоминания: мы объявляем переменные при помощи операторов var, let и const. Мы назначаем значение переменной, используя оператор присваивания. Во многих случаях объявление и присваивание значения комбинируются в один шаг. Поднятие переменных работает по-разному, в зависимости от того, как была объявлена переменная. 
Поднятие переменных, объявленных при помощи var
Когда интерпретатор поднимает переменную, объявленную при помощи var, он инициализирует ее со значением undefined.
Первый вывод console.log(foo) — undefined, потому что foo поднимается и получает значение по умолчанию (а не потому что переменная вообще не объявлена). А вот использование необъявленной переменной приведет к ошибке ReferenceError --- Использовав необъявленную переменную до присвоения ей значения, вы также получите ошибку ReferenceError, потому что здесь нет объявления, которое могло бы подняться.Boolean

Переменные, объявленные при помощи let и const, поднимаются, но не инициализируются с дефолтным значением. Попытка доступа к let или const-переменной до ее объявления приведет к ReferenceError. Обратите внимание, что интерпретатор по-прежнему поднимает foo: сообщение об ошибке говорит нам, что где-то эта переменная инициализирована. */

